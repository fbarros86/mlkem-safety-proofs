require "indcpa.jinc"
require "verify.jinc"

inline
fn __crypto_kem_keypair_jazz(reg ui64 pkp, reg ui64 skp, reg ptr u8[MLKEM_SYMBYTES*2] randomnessp)
requires{is_arr_init(randomnessp,0,MLKEM_SYMBYTES*2) && is_mem_init((64u)pkp,MLKEM_INDCPA_PUBLICKEYBYTES) && 
         is_mem_init((64u)skp,MLKEM_POLYVECBYTES + MLKEM_INDCPA_PUBLICKEYBYTES + 4*8 + MLKEM_SYMBYTES)}
{
  #mmx reg ptr u8[MLKEM_SYMBYTES*2] s_randomnessp;
  reg ptr u8[MLKEM_SYMBYTES] randomnessp1 randomnessp2;

  stack u8[32] h_pk;
  #mmx reg ui64 s_skp s_pkp;
  reg u64 t64;
  inline int i;

  s_randomnessp = randomnessp;
  s_pkp = pkp;
  s_skp = skp;

  randomnessp1 = randomnessp[0:MLKEM_SYMBYTES];
  __indcpa_keypair(pkp, skp, randomnessp1);

  skp = s_skp;
  skp += MLKEM_POLYVECBYTES;
  pkp = s_pkp;

  for i=0 to MLKEM_INDCPA_PUBLICKEYBYTES/8
  {
    t64 = (u64)[(64u)(pkp + 8*i)];
    (u64)[(64u)skp] = t64;
    skp += 8;
  }

  s_skp = skp;
  pkp = s_pkp;

  h_pk = _sha3_256A_M1184(h_pk, pkp);
  skp = s_skp;

  for i=0 to 4
  {
    t64 = h_pk[u64 i];
    (u64)[(64u)skp] = t64;
    skp += 8;
  }

  randomnessp = s_randomnessp;
  randomnessp2 = randomnessp[MLKEM_SYMBYTES:MLKEM_SYMBYTES];

  for i=0 to MLKEM_SYMBYTES/8
  {
    t64 = randomnessp2[u64 i];
    (u64)[(64u)skp] = t64;
    skp += 8;
  }
}

inline
fn __crypto_kem_enc_jazz(reg ui64 ctp, reg ui64 shkp, reg ui64 pkp, reg ptr u8[MLKEM_SYMBYTES] randomnessp)
requires{
  is_arr_init(randomnessp,0,MLKEM_SYMBYTES) && is_mem_init((64u)ctp,1920) && 
  is_mem_init((64u)shkp,MLKEM_SYMBYTES) && is_mem_init((64u)pkp,MLKEM_INDCPA_PUBLICKEYBYTES)
}
{
  inline int i;

  stack u8[MLKEM_SYMBYTES * 2] buf kr;
  #mmx reg ui64 s_pkp s_ctp s_shkp;
  reg u64 t64;

  s_pkp = pkp;
  s_ctp = ctp;
  s_shkp = shkp;
  
  for i=0 to MLKEM_SYMBYTES/8
  {
    t64 = randomnessp[u64 i];
    buf[u64 i] = t64;
  }

  buf[MLKEM_SYMBYTES:MLKEM_SYMBYTES] = _sha3_256A_M1184(buf[MLKEM_SYMBYTES:MLKEM_SYMBYTES], pkp);

  kr = _sha3_512A_A64(kr, buf);

  pkp = s_pkp;

  __indcpa_enc_0(s_ctp, buf[0:MLKEM_INDCPA_MSGBYTES], pkp, kr[MLKEM_SYMBYTES:MLKEM_SYMBYTES]);

  shkp = s_shkp;

  for i=0 to MLKEM_SYMBYTES/8
  {
    t64 = kr[u64 i];
    (u64)[(64u)(shkp + 8*i)] = t64;
  }
}

inline
fn __crypto_kem_dec_jazz(reg ui64 shkp, reg ui64 ctp, reg ui64 skp)
requires{
  is_mem_init((64u)shkp,MLKEM_SYMBYTES) && is_mem_init((64u)ctp,MLKEM_INDCPA_CIPHERTEXTBYTES) && 
  is_mem_init((64u)skp,2400)
}
{
  stack u8[MLKEM_INDCPA_CIPHERTEXTBYTES] ctpc;
  stack u8[2*MLKEM_SYMBYTES] kr buf;
  #mmx reg ui64 s_skp s_ctp s_shkp;
  #mmx reg u64 s_cnd;
  reg ui64 pkp hp zp;
  reg u64 t64 cnd;
  inline int i;

  s_shkp = shkp;
  s_ctp = ctp;

  buf[0:MLKEM_INDCPA_MSGBYTES] = __indcpa_dec_1(buf[0:MLKEM_INDCPA_MSGBYTES], ctp, skp);

  hp = skp;
  hp += 32 + (24 * MLKEM_K * MLKEM_N>>3);

  /* fixme: should loads be 256-bits long? */
  for i=0 to MLKEM_SYMBYTES/8
  {
    t64 = (u64)[(64u)(hp + 8*i)];
    buf.[u64 MLKEM_SYMBYTES + 8*i] = t64;
  }

  s_skp = skp;

  kr = _sha3_512A_A64(kr, buf);

  pkp = s_skp;
  pkp += 12 * MLKEM_K * MLKEM_N>>3;

  ctpc = __indcpa_enc_1(ctpc, buf[0:MLKEM_INDCPA_MSGBYTES], pkp, kr[MLKEM_SYMBYTES:MLKEM_SYMBYTES]);

  ctp = s_ctp;

  cnd = __verify(ctp, ctpc);
  s_cnd = cnd; /* avoidable ? */

  ctp = s_ctp;
  zp = s_skp;
  zp += 64;
  zp += 24 * MLKEM_K * MLKEM_N>>3;

  /* fixme: should this be done in memory? */
  shkp = s_shkp;

  _shake256_M32__M32_M1088(shkp, zp, ctp);

  shkp = s_shkp;
  cnd = s_cnd;

   __cmov(shkp, kr[0:MLKEM_SYMBYTES], cnd); 
}

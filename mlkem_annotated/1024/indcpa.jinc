require "params.jinc"
require "poly.jinc"
require "polyvec.jinc"
require "gen_matrix.jinc"

inline
fn __indcpa_keypair(#spill_to_mmx reg ui64 pkp skp, reg ptr u8[MLKEM_SYMBYTES] randomnessp)
requires{is_arr_init(randomnessp,0,MLKEM_SYMBYTES) && is_mem_init((64u) pkp,MLKEM_INDCPA_PUBLICKEYBYTES) && is_mem_init((64u) skp,MLKEM_POLYVECBYTES)}
{
  stack u16[MLKEM_K*MLKEM_VECN] aa;
  stack u16[MLKEM_VECN] e pkpv skpv;
  stack u8[64] buf;
  stack u8[MLKEM_SYMBYTES] publicseed noiseseed;
  stack u8[33] inbuf;
  reg u64 t64;
  reg u8 nonce;
  inline int i;
  reg u64 transposed;
  reg u64 pkp_w skp_w;
  pkp_w = (64u)pkp;
  skp_w = (64u)skp;
  
  () = #spill(pkp_w, skp_w);

  for i = 0 to MLKEM_SYMBYTES/8
  {
    t64 = randomnessp[u64 i];
    inbuf[u64 i] = t64;
  }
  inbuf[32] = MLKEM_K;

  buf = _sha3_512A_A33(buf, inbuf);

  for i = 0 to MLKEM_SYMBYTES/8
  {
    #declassify t64 = buf[u64 i];
    publicseed[u64 i] = t64;
    t64 = buf[u64 i + MLKEM_SYMBYTES/8];
    noiseseed[u64 i] = t64;
  }

  transposed = 0;
  aa = _gen_matrix_avx2(aa, publicseed, transposed);

  nonce = 0;
  skpv[0:MLKEM_N], skpv[MLKEM_N:MLKEM_N], skpv[2*MLKEM_N:MLKEM_N], skpv[3*MLKEM_N:MLKEM_N] = _poly_getnoise_eta1_4x(skpv[0:MLKEM_N], skpv[MLKEM_N:MLKEM_N], skpv[2*MLKEM_N:MLKEM_N], skpv[3*MLKEM_N:MLKEM_N], noiseseed, nonce);

  nonce = 4;
  e[0:MLKEM_N], e[MLKEM_N:MLKEM_N], e[2*MLKEM_N:MLKEM_N], e[3*MLKEM_N:MLKEM_N] = _poly_getnoise_eta1_4x(e[0:MLKEM_N], e[MLKEM_N:MLKEM_N], e[2*MLKEM_N:MLKEM_N], e[3*MLKEM_N:MLKEM_N], noiseseed, nonce);

  skpv = __polyvec_ntt(skpv);
  e    = __polyvec_ntt(e);


  for i = 0 to MLKEM_K
  {
    pkpv[i*MLKEM_N:MLKEM_N] = __polyvec_pointwise_acc(pkpv[i*MLKEM_N:MLKEM_N], aa[i*MLKEM_VECN:MLKEM_VECN], skpv);
    pkpv[i*MLKEM_N:MLKEM_N] = _poly_frommont(pkpv[i*MLKEM_N:MLKEM_N]);
  }

  pkpv = __polyvec_add2(pkpv, e);
  pkpv = __polyvec_reduce(pkpv);

  pkp_w = (64u)pkp;
  skp_w = (64u)skp;

  () = #unspill(pkp_w, skp_w);

  __polyvec_tobytes(skp, skpv);
  __polyvec_tobytes(pkp, pkpv);

  pkp += MLKEM_POLYVECBYTES;

  for i = 0 to MLKEM_SYMBYTES/8
  {
    t64 = publicseed[u64 i];
    (u64)[(64u) pkp] = t64;
    pkp += 8;
  }
}

inline
fn __indcpa_enc_0(#mmx reg ui64 sctp, reg ptr u8[MLKEM_INDCPA_MSGBYTES] msgp, reg ui64 pkp, reg ptr u8[MLKEM_SYMBYTES] noiseseed)
requires{is_arr_init(msgp,0,MLKEM_INDCPA_MSGBYTES) && is_arr_init(noiseseed,0,MLKEM_SYMBYTES) &&
         is_mem_init((64u) sctp,20 * MLKEM_VECN/16 + MLKEM_POLYVECCOMPRESSEDBYTES) && 
         is_mem_init((64u) pkp,MLKEM_POLYVECBYTES + MLKEM_SYMBYTES) }
{
  stack u16[MLKEM_VECN] pkpv sp ep bp;
  stack u16[MLKEM_K*MLKEM_VECN] aat;
  stack u16[MLKEM_N] k epp v;
  stack u8[MLKEM_SYMBYTES] publicseed;
  #mmx reg ptr u8[MLKEM_SYMBYTES] s_noiseseed;
  reg ptr u8[MLKEM_SYMBYTES] lnoiseseed;
  reg u64 t64;
  reg ui64 i ctp;
  reg u8 nonce;
  inline int w;
  reg u64 transposed;

  pkpv = __polyvec_frombytes(pkp);

  i = 0;
  pkp += MLKEM_POLYVECBYTES;
  while (i < MLKEM_SYMBYTES/8)
  {
    #declassify t64 = (u64)[(64u) pkp];
    publicseed.[u64 8 * (int)i] = t64;
    pkp += 8;
    i += 1;
  }

  k = _poly_frommsg_1(k, msgp);

  s_noiseseed = noiseseed;

  transposed = 1;
  aat = _gen_matrix_avx2(aat, publicseed, transposed);

  lnoiseseed = s_noiseseed;
  nonce = 0;
  sp[0:MLKEM_N], sp[MLKEM_N:MLKEM_N], sp[2*MLKEM_N:MLKEM_N], sp[3*MLKEM_N:MLKEM_N] = _poly_getnoise_eta1_4x(sp[0:MLKEM_N], sp[MLKEM_N:MLKEM_N], sp[2*MLKEM_N:MLKEM_N], sp[3*MLKEM_N:MLKEM_N], lnoiseseed, nonce);

  lnoiseseed = s_noiseseed;
  nonce = 4;
  ep[0:MLKEM_N], ep[MLKEM_N:MLKEM_N], ep[2*MLKEM_N:MLKEM_N], ep[3*MLKEM_N:MLKEM_N] = _poly_getnoise_eta1_4x(ep[0:MLKEM_N], ep[MLKEM_N:MLKEM_N], ep[2*MLKEM_N:MLKEM_N], ep[3*MLKEM_N:MLKEM_N], lnoiseseed, nonce);

  lnoiseseed = s_noiseseed;
  nonce = 8;
  epp = _poly_getnoise_eta2(epp, noiseseed, nonce);

  sp = __polyvec_ntt(sp);

  for w = 0 to MLKEM_K
  {
    bp[w*MLKEM_N:MLKEM_N] = __polyvec_pointwise_acc(bp[w*MLKEM_N:MLKEM_N], aat[w*MLKEM_VECN:MLKEM_VECN], sp);
  }

  v = __polyvec_pointwise_acc(v, pkpv, sp);

  bp = __polyvec_invntt(bp);
  v = _poly_invntt(v);

  bp = __polyvec_add2(bp, ep);
  v = _poly_add2(v, epp);
  v = _poly_add2(v, k);
  bp = __polyvec_reduce(bp);
  v  = __poly_reduce(v);

  ctp = sctp;

  __polyvec_compress(ctp, bp);
  ctp += MLKEM_POLYVECCOMPRESSEDBYTES;
  v = _poly_compress(ctp, v);
}

inline
fn __indcpa_enc_1(
  stack u8[MLKEM_INDCPA_CIPHERTEXTBYTES] ctp,
  reg ptr u8[MLKEM_INDCPA_MSGBYTES] msgp,
  reg ui64 pkp,
  reg ptr u8[MLKEM_SYMBYTES] noiseseed)
  ->
  stack u8[MLKEM_INDCPA_CIPHERTEXTBYTES]
requires{is_arr_init(msgp,0,MLKEM_INDCPA_MSGBYTES) && is_arr_init(noiseseed,0,MLKEM_SYMBYTES) &&
         is_mem_init((64u) pkp,MLKEM_POLYVECBYTES + MLKEM_SYMBYTES)}
ensures{is_arr_init(result.0,0,MLKEM_INDCPA_CIPHERTEXTBYTES)}  
{
  stack u16[MLKEM_VECN] pkpv sp ep bp;
  stack u16[MLKEM_K*MLKEM_VECN] aat;
  stack u16[MLKEM_N] k epp v;
  stack u8[MLKEM_SYMBYTES] publicseed;
  #mmx reg ptr u8[MLKEM_SYMBYTES] s_noiseseed;
  reg ptr u8[MLKEM_SYMBYTES] lnoiseseed;
  reg ui64 i;
  reg u64 t64;
  reg u8 nonce;
  inline int w;
  reg u64 transposed;

  pkpv = __polyvec_frombytes(pkp);

  i = 0;
  pkp += MLKEM_POLYVECBYTES;
  while (i < MLKEM_SYMBYTES/8)
  {
    #declassify t64 = (u64)[(64u) pkp];
    publicseed.[u64 8*(int)i] = t64;
    pkp += 8;
    i += 1;
  }

  k = _poly_frommsg_1(k, msgp);

  s_noiseseed = noiseseed;

  transposed = 1;
  aat = _gen_matrix_avx2(aat, publicseed, transposed);

  lnoiseseed = s_noiseseed;
  nonce = 0;
  sp[0:MLKEM_N], sp[MLKEM_N:MLKEM_N], sp[2*MLKEM_N:MLKEM_N], sp[3*MLKEM_N:MLKEM_N] = _poly_getnoise_eta1_4x(sp[0:MLKEM_N], sp[MLKEM_N:MLKEM_N], sp[2*MLKEM_N:MLKEM_N], sp[3*MLKEM_N:MLKEM_N], lnoiseseed, nonce);

  lnoiseseed = s_noiseseed;
  nonce = 4;
  ep[0:MLKEM_N], ep[MLKEM_N:MLKEM_N], ep[2*MLKEM_N:MLKEM_N], ep[3*MLKEM_N:MLKEM_N] = _poly_getnoise_eta1_4x(ep[0:MLKEM_N], ep[MLKEM_N:MLKEM_N], ep[2*MLKEM_N:MLKEM_N], ep[3*MLKEM_N:MLKEM_N], lnoiseseed, nonce);

  lnoiseseed = s_noiseseed;
  nonce = 8;
  epp = _poly_getnoise_eta2(epp, noiseseed, nonce);

  sp = __polyvec_ntt(sp);

  for w = 0 to MLKEM_K
  {
    bp[w*MLKEM_N:MLKEM_N] = __polyvec_pointwise_acc(bp[w*MLKEM_N:MLKEM_N], aat[w*MLKEM_VECN:MLKEM_VECN], sp);
  }

  v = __polyvec_pointwise_acc(v, pkpv, sp);

  bp = __polyvec_invntt(bp);
  v = _poly_invntt(v);

  bp = __polyvec_add2(bp, ep);
  v = _poly_add2(v, epp);
  v = _poly_add2(v, k);
  bp = __polyvec_reduce(bp);
  v  = __poly_reduce(v);

  ctp[0:MLKEM_POLYVECCOMPRESSEDBYTES+2] = __polyvec_compress_1(ctp[0:MLKEM_POLYVECCOMPRESSEDBYTES+2], bp);
  ctp[MLKEM_POLYVECCOMPRESSEDBYTES:MLKEM_POLYCOMPRESSEDBYTES], v = _poly_compress_1(ctp[MLKEM_POLYVECCOMPRESSEDBYTES:MLKEM_POLYCOMPRESSEDBYTES], v);

  return ctp;
}

inline
fn __indcpa_dec_1(reg ptr u8[MLKEM_INDCPA_MSGBYTES] msgp, reg ui64 ctp, reg ui64 skp) -> reg ptr u8[MLKEM_INDCPA_MSGBYTES]
requires{is_mem_init((64u) ctp,MLKEM_POLYVECCOMPRESSEDBYTES + MLKEM_POLYCOMPRESSEDBYTES) && is_mem_init((64u) skp,MLKEM_POLYVECBYTES)}
ensures{is_arr_init(result.0,0,MLKEM_INDCPA_MSGBYTES)}
{
  stack u16[MLKEM_N] t v mp;
  stack u16[MLKEM_VECN] bp skpv;

  bp = __polyvec_decompress(ctp);
  ctp += MLKEM_POLYVECCOMPRESSEDBYTES;
  v = _poly_decompress(v, ctp);

  skpv = __polyvec_frombytes(skp);

  bp = __polyvec_ntt(bp);
  t = __polyvec_pointwise_acc(t, skpv, bp);
  t = _poly_invntt(t);

  mp = _poly_sub(mp, v, t);
  mp = __poly_reduce(mp);

  msgp, mp = _poly_tomsg_1(msgp, mp);

  return msgp;
}

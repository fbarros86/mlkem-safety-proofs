require "params.jinc"
require "../../common/avx2/poly.jinc"

u16 pc_mask_s = 0x1F;
u16 pc_shift1_s = 0x400;
u16 pc_shift2_s = 0x2001;
u32 pc_shift3_s = 0x4000001;
u64 pc_sllvdidx_s = 0xC;
u8[32] pc_shufbidx_s = { 0, 1, 2, 3, 4,-1,-1,-1,-1,-1, 8, 9,10,11,12,-1,
                         9,10,11,12,-1, 0, 1, 2, 3, 4,-1,-1,-1,-1,-1, 8 };
/*
_poly_compress: compresses a polynomial to 5 bits per coefficient and packs
                in byte array stored in rp

requires: input coefficients to be in the range [0..2q)
      rp to point to 160 byte valid region

ensures:
    only 128 bytes pointed by rp are modified in memory
    these bytes encode the compressed polynomial

    it returns the input polynomial reduced to the range [0..q)

*/
fn _poly_compress(reg ui64 rp, reg ptr u16[MLKEM_N] a) -> reg ptr u16[MLKEM_N]
requires {is_arr_init(a,0,2*MLKEM_N) && is_mem_init((64u) rp,MLKEM_POLYCOMPRESSEDBYTES)}
ensures {is_arr_init(result.0,0,2*MLKEM_N)}
{
  inline int i;
  reg u256 f0 f1 v mask shift1 shift2 shift3 sllvdidx shufbidx;
  reg ptr u16[16] x16p;
  reg u128 t0 t1;

  a = _poly_csubq(a);

  x16p = jvx16;
  v = x16p[u256 0];
  shift1 = #VPBROADCAST_16u16(pc_shift1_s);
  mask = #VPBROADCAST_16u16(pc_mask_s);
  shift2 = #VPBROADCAST_16u16(pc_shift2_s);
  shift3 = #VPBROADCAST_8u32(pc_shift3_s);
  sllvdidx = #VPBROADCAST_4u64(pc_sllvdidx_s);
  shufbidx = pc_shufbidx_s[u256 0];

  for i = 0 to MLKEM_N/32
  {
    f0 = a[u256 2*i];
    f1 = a[u256 2*i + 1];
    f0 = #VPMULH_16u16(f0, v);
    f1 = #VPMULH_16u16(f1, v);
    f0 = #VPMULHRS_16u16(f0, shift1);
    f1 = #VPMULHRS_16u16(f1, shift1);
    f0 = #VPAND_256(f0, mask);
    f1 = #VPAND_256(f1, mask);
    f0 = #VPACKUS_16u16(f0, f1);
    f0 = #VPMADDUBSW_256(f0, shift2);
    f0 = #VPMADDWD_256(f0, shift3);
    f0 = #VPSLLV_8u32(f0, sllvdidx);
    f0 = #VPSRLV_4u64(f0, sllvdidx);
    f0 = #VPSHUFB_256(f0, shufbidx);
    t0 = (128u)f0;
    t1 = #VEXTRACTI128(f0, 1);
    t0 = #BLENDV_16u8(t0, t1, (128u)shufbidx);
    (u128)[(64u)(rp + 20*i)] = t0;
    (u32)[(64u)(rp + 20*i + 16)] = (32u)t1;
  }

  return a;
}

/*
_poly_compress_1: same as previous function but writes to the stack
*/
inline
fn _poly_compress_1(reg ptr u8[MLKEM_POLYCOMPRESSEDBYTES] rp, reg ptr u16[MLKEM_N] a) -> reg ptr u8[MLKEM_POLYCOMPRESSEDBYTES], reg ptr u16[MLKEM_N]
requires {is_arr_init(a,0,2*MLKEM_N)}
ensures {is_arr_init(result.0,0,MLKEM_POLYCOMPRESSEDBYTES) && is_arr_init(result.1,0,2*MLKEM_N)}
{
  inline int i;
  reg u256 f0 f1 v mask shift1 shift2 shift3 sllvdidx shufbidx;
  reg ptr u16[16] x16p;
  reg u128 t0 t1;

  a = _poly_csubq(a);

  x16p = jvx16;
  v = x16p[u256 0];
  shift1 = #VPBROADCAST_16u16(pc_shift1_s);
  mask = #VPBROADCAST_16u16(pc_mask_s);
  shift2 = #VPBROADCAST_16u16(pc_shift2_s);
  shift3 = #VPBROADCAST_8u32(pc_shift3_s);
  sllvdidx = #VPBROADCAST_4u64(pc_sllvdidx_s);
  shufbidx = pc_shufbidx_s[u256 0];

  for i = 0 to MLKEM_N/32
  {
    f0 = a[u256 2*i];
    f1 = a[u256 2*i + 1];
    f0 = #VPMULH_16u16(f0, v);
    f1 = #VPMULH_16u16(f1, v);
    f0 = #VPMULHRS_16u16(f0, shift1);
    f1 = #VPMULHRS_16u16(f1, shift1);
    f0 = #VPAND_256(f0, mask);
    f1 = #VPAND_256(f1, mask);
    f0 = #VPACKUS_16u16(f0, f1);
    f0 = #VPMADDUBSW_256(f0, shift2);
    f0 = #VPMADDWD_256(f0, shift3);
    f0 = #VPSLLV_8u32(f0, sllvdidx);
    f0 = #VPSRLV_4u64(f0, sllvdidx);
    f0 = #VPSHUFB_256(f0, shufbidx);
    t0 = (128u)f0;
    t1 = #VEXTRACTI128(f0, 1);
    t0 = #BLENDV_16u8(t0, t1, (128u)shufbidx);
    rp.[u128 20*i] = t0;
    rp.[u32 20*i + 16] = (32u)t1;
  }

  return rp, a;
}

u8[32] pd_jshufbidx = {0,0,0,1,1,1,1,2,2,3,3,3,3,4,4,4,
                       5,5,5,6,6,6,6,7,7,8,8,8,8,9,9,9};
u16[16] pd_mask_s = {31,992,124,3968,496,62,1984,248,
                     31,992,124,3968,496,62,1984,248};
u16[16] pd_shift_s = {1024,32,256,8,64,512,16,128,
                      1024,32,256,8,64,512,16,128};
/*
_poly_decompress: decompresses a polynomial from 5 bits per coefficient from
                input array ap

requires: ap to point to 160 byte valid region

ensures:
    memory unchanged (writes to stack)
    every output coefficient is in the range [0..q)

*/
fn _poly_decompress(reg mut ptr u16[MLKEM_N] rp, reg ui64 ap) -> reg ptr u16[MLKEM_N]
requires {is_mem_init((64u) ap, MLKEM_POLYCOMPRESSEDBYTES)}
ensures {is_arr_init(result.0,0,2*MLKEM_N)}
{
  inline int i;
  reg u256 f q shufbidx mask shift;
  reg u128 t;
  reg u16 ti;
  reg ptr u16[16] x16p;
  stack u128 sh;

  x16p = jqx16;
  q = x16p[u256 0];
  shufbidx = pd_jshufbidx[u256 0];
  mask = pd_mask_s[u256 0];
  shift = pd_shift_s[u256 0];

  f = #set0_256();

  for i = 0 to MLKEM_N/16
  {
    t = (128u)(u64)[(64u)(ap + 10*i)];
    ti = (16u)(u16)[(64u)(ap + 10*i + 8)];
    t = #VPINSR_8u16(t, ti, 4);
    sh = t;
    f = #VPBROADCAST_2u128(sh);

    f = #VPSHUFB_256(f, shufbidx);
    f = #VPAND_256(f, mask);
    f = #VPMULL_16u16(f, shift);
    f = #VPMULHRS_16u16(f, q);
    rp[u256 i] = f;
  }

  return rp;
}

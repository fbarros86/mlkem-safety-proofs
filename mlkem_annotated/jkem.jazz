require "kem.jinc"

export fn jade_kem_mlkem_mlkem768_amd64_avx2_keypair_derand(reg ui64 public_key secret_key coins) -> reg u64
requires {is_mem_init((64u) coins, MLKEM_SYMBYTES*2) && 
          is_mem_init((64u) public_key, MLKEM_INDCPA_PUBLICKEYBYTES) && 
          is_mem_init((64u) secret_key, MLKEM_POLYVECBYTES + MLKEM_INDCPA_PUBLICKEYBYTES + 4*8 + MLKEM_SYMBYTES)} 
{
  reg u64 r;
  stack u8[MLKEM_SYMBYTES*2] randomness;
  reg ptr u8[MLKEM_SYMBYTES*2] randomnessp;
  inline int i;

  _ = #init_msf();

  public_key = public_key;
  secret_key = secret_key;

  for i = 0 to MLKEM_SYMBYTES*2
  {
     randomness[i] = (u8)[(64u)(coins + i)];
  }

  randomnessp = randomness;

  __crypto_kem_keypair_jazz(public_key, secret_key, randomnessp);
  ?{}, r = #set0();
  return r;
}

export fn jade_kem_mlkem_mlkem768_amd64_avx2_enc_derand(reg ui64 ciphertext shared_secret public_key coins) -> reg u64
requires {is_mem_init((64u) coins, MLKEM_SYMBYTES) && 
          is_mem_init((64u) ciphertext, 1920) && 
          is_mem_init((64u) shared_secret, MLKEM_SYMBYTES) && 
          is_mem_init((64u) public_key, MLKEM_INDCPA_PUBLICKEYBYTES)}
{
  reg u64 r;
  stack u8[MLKEM_SYMBYTES] randomness;
  reg ptr u8[MLKEM_SYMBYTES] randomnessp;
  inline int i;

  _ = #init_msf();

  ciphertext = ciphertext;
  shared_secret = shared_secret;
  public_key = public_key;

  for i = 0 to MLKEM_SYMBYTES 
  {
     randomness[i] = (u8)[(64u)(coins + i)];
  }

  randomnessp = randomness;

  __crypto_kem_enc_jazz(ciphertext, shared_secret, public_key, randomnessp);
  ?{}, r = #set0();
  return r;
}

export fn jade_kem_mlkem_mlkem768_amd64_avx2_keypair(reg ui64 public_key secret_key) -> reg u64
requires{
  is_mem_init((64u) public_key, MLKEM_INDCPA_PUBLICKEYBYTES) && 
  is_mem_init((64u) secret_key, MLKEM_POLYVECBYTES + MLKEM_INDCPA_PUBLICKEYBYTES + 4*8 + MLKEM_SYMBYTES)
}
{
  reg u64 r;
  stack u8[MLKEM_SYMBYTES*2] randomness;
  reg ptr u8[MLKEM_SYMBYTES*2] randomnessp;

  public_key = public_key;
  secret_key = secret_key;

  randomnessp = randomness;
  randomnessp = #randombytes(randomnessp);
  _ = #init_msf();

  __crypto_kem_keypair_jazz(public_key, secret_key, randomnessp);
  ?{}, r = #set0();
  return r;
}

export fn jade_kem_mlkem_mlkem768_amd64_avx2_enc(reg ui64 ciphertext shared_secret public_key) -> reg u64
requires{
  is_mem_init((64u) ciphertext, 1920) && 
  is_mem_init((64u) shared_secret, MLKEM_SYMBYTES) && 
  is_mem_init((64u) public_key, MLKEM_INDCPA_PUBLICKEYBYTES)
}
{
  reg u64 r;
  stack u8[MLKEM_SYMBYTES] randomness;
  reg ptr u8[MLKEM_SYMBYTES] randomnessp;

  ciphertext = ciphertext;
  shared_secret = shared_secret;
  public_key = public_key;

  randomnessp = randomness;
  randomnessp = #randombytes(randomnessp);
  _ = #init_msf();

  __crypto_kem_enc_jazz(ciphertext, shared_secret, public_key, randomnessp);
  ?{}, r = #set0();
  return r;
}

export fn jade_kem_mlkem_mlkem768_amd64_avx2_dec(reg ui64 shared_secret ciphertext secret_key) -> reg u64
requires{
  is_mem_init((64u) shared_secret, MLKEM_SYMBYTES) && 
  is_mem_init((64u) ciphertext, MLKEM_INDCPA_CIPHERTEXTBYTES) && 
  is_mem_init((64u) secret_key, 2400)
}
{
  reg u64 r;

  _ = #init_msf();

  __crypto_kem_dec_jazz(shared_secret, ciphertext, secret_key);
  ?{}, r = #set0();
  return r;
}
